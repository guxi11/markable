/**
 * markable - make non-English Markdown plain text markable
 * Copyright (c) 2020, Guxi11. (MIT Licensed)
 * https://github.com/hbhde/markable
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.markable = factory());
}(this, (function () { 'use strict';

  /**
   * Helpers
   */
  var caret = /(^|[^\[])\^/g;

  function edit(regex) {
    regex = regex.source || regex;
    var obj = {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex);
      }
    };
    return obj;
  }

  var helpers = {
    edit: edit
  };

  var _symbols;

  /**
   * Rules
   * Supported Languages: Chinese
   */
  var symbols = (_symbols = {
    '=`=': /[·]/,
    '=~=': /[～]/,
    '={=': /[「]/,
    '=}=': /[」]/,
    '=[=': /[【]/,
    '=]=': /[】]/,
    '=(=': /[（]/,
    '=)=': /[）]/
  }, _symbols["=)="] = /[）]/, _symbols['=:='] = /[：]/, _symbols['=!='] = /[！]/, _symbols['=<='] = /[《〈]/, _symbols['=>='] = /[》〉]/, _symbols['=.='] = /[。]/, _symbols['=_='] = /[——]/, _symbols['=$='] = /[¥]/, _symbols['=|='] = /[｜]/, _symbols);
  var symbols_1 = symbols;

  var edit$1 = helpers.edit;
  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^\n+/,
    fences: /^ {0,3}(=`={3,}(?=[^\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1=`=* *(?:\n+|$)|$)/,
    blockquote: /^( {0,3}=>= ?([^\n]*)(?:\n|$))+/,
    text: /^[^\n]+/
  };
  block.fences = edit$1(block.fences).replace(/=`=/g, symbols_1['=`=']).getRegex();
  block.blockquote = edit$1(block.blockquote).replace(/=>=/g, symbols_1['=>=']).getRegex();
  var rules = {
    block: block
  };

  var block$1 = rules.block;
  /**
   * Block Translator
   */

  var Translator_1 = /*#__PURE__*/function () {
    function Translator() {
      this.rules = block$1;
      this.dest = '';
    }

    Translator.translate = function translate(src) {
      var translator = new Translator();
      return translator.translate(src);
    };

    var _proto = Translator.prototype;

    _proto.translate = function translate(src) {
      // preprocessing
      src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
      var cap;

      while (src) {
        // newline
        if (cap = this.rules.newline.exec(src)) {
          src = src.substring(cap[0].length);
          this.dest += cap[0];
        } // fences


        if (cap = this.rules.fences.exec(src)) {
          src = src.substring(cap[0].length);
          this.dest += cap[0].replace(/[·]{3}/g, '```');
        } // blockquote


        if (cap = this.rules.blockquote.exec(src)) {
          src = src.substring(cap[0].length);
          this.dest += cap[0].replace(/》 /, '> ');
        } // text


        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          this.dest += cap[0];
        }
      }

      return this.dest;
    };

    return Translator;
  }();

  /**
   * Markable
   */

  function markable(src) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('markable(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('markable(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    return Translator_1.translate(src);
  }
  /**
   * Expose
   */

  var markable_1 = markable;

  return markable_1;

})));
