/**
 * markable - make non-English Markdown plain text markable
 * Copyright (c) 2020, Guxi11. (MIT Licensed)
 * https://github.com/hbhde/markable
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.markable = factory());
}(this, (function () { 'use strict';

  /**
   * Helpers
   */
  var caret = /(^|[^\[])\^/g;

  function edit(regex) {
    regex = regex.source;
    var obj = {
      replace: function replace(name, val) {
        val = val.source;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      replaceAllByDict: function replaceAllByDict(dict) {
        for (var key in dict) {
          var name = key,
              val = dict[key];
          val = val.source;
          val = val.replace(caret, '$1');
          regex = regex.replace(RegExp(name, 'g'), val);
        }

        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex);
      }
    };
    return obj;
  }

  var helpers = {
    edit: edit
  };

  /**
   * Symbols
   * Supported Languages: Chinese
   */
  var symbols = {
    '=`=': /`·/,
    '=~=': /~～/,
    '={=': /「/,
    '=}=': /」/,
    '=<=': /<《〈/,
    '=>=': />》〉/,
    '=:=': /:：/,
    '=!=': /!！/,
    '=_=': /——/,
    '=$=': /¥/,
    '="=': /"“”/,
    "='=": /'‘’/,
    '=\\\\\\[=': /\[【/,
    // Escaping twice
    '=\\\\\\]=': /\]】/,
    '=\\\\\\(=': /\(（/,
    '=\\\\\\)=': /\)）/,
    '=\\\\\\|=': /｜/,
    '=\\\\\\.=': /。/
  };
  var symbols_1 = symbols;

  var edit$1 = helpers.edit;
  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^\n+/,
    fences: /^ {0,3}([=`=]{3,}(?=[^\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[=`=]* *(?:\n+|$)|$)/,
    blockquote: /^ {0,3}[=>=]+(([^\n]*)(?:\n|$))/,
    listquote: /^ *bull ?blockquote/,
    text: /^[^\n]+/
  };
  block.bullet = /(?:[*+-]|\d{1,9}\.)/;
  block.listquote = edit$1(block.listquote).replace('bull', block.bullet).replace('blockquote', block.blockquote).getRegex();
  /**
   * Inline-Level Grammar
   */

  var inline = {
    link: /^[=!=]?[=\[=](label)[=\]=][=\(=]\s*(href)(?:\s+(title))?\s*[=\)=]/,
    reflink: /^[=!=]?[=\[=](label)[=\]=][=\[=](id)[=\]=]/,
    linkdefinition: /^[=\[=](id)[=\]=][=:=]\s*(href)(?:\s+(title))?/,
    code: /^([=`=]+)([^=`=]|[^=`=][\s\S]*?[^=`=])\1(?![=`=])/,
    text: /^([=`=]+|[^=`=])(?:[\s\S]*?(?:(?=[\\<!=\[==`=*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
  };
  inline._label = /(?:[=\[=][^=\[==\]=]*[=\]=]|\\.|[=`=][^=`=]*[=`=]|[^=\[==\]=\\=`=])*?/;
  inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
  inline._title = /[="=](?:\\[="=]?|[^="=\\])*[="=]|[='=](?:\\[='=]?|[^='=\\])*[='=]|[=\(=](?:\\[=\)=]?|[^)\\])*[=\)=]/;
  inline._id = /(?!\s*[=\]=])((?:\\[=\[==\]=]?|[^=\[==\]=\\])+)/;
  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).replace('id', inline._id).getRegex();
  inline.linkdefinition = edit$1(inline.linkdefinition).replace('id', inline._id).replace('href', inline._href).replace('title', inline._title).getRegex();
  /**
   * Grammar Translate Symbols
   */

  [block, inline].map(function (grammer) {
    for (var key in grammer) {
      grammer[key] = edit$1(grammer[key]).replaceAllByDict(symbols_1).getRegex();
    }
  });
  var rules = {
    block: block,
    inline: inline
  };

  var inline$1 = rules.inline;
  /**
   * InlineTranslator
   */

  var InlineTranslator_1 = /*#__PURE__*/function () {
    function InlineTranslator() {
      this.rules = inline$1;
    }

    InlineTranslator.translate = function translate(src) {
      var translator = new InlineTranslator();
      return translator.translate(src);
    };

    var _proto = InlineTranslator.prototype;

    _proto.translate = function translate(src) {
      var dest = '',
          cap,
          left,
          right;

      while (src) {
        // link
        if (cap = this.rules.link.exec(src)) {
          src = src.substring(cap[0].length);
          left = cap[0].substring(0, cap[0].indexOf(cap[1])).replace(/！/, '!').replace(/【/, '[');
          right = cap[0].substring(cap[0].indexOf(cap[1]) + cap[1].length).replace(/】/, ']').replace(/（/, '(').replace(/）/, ')').replace(/[“”]/g, '"');
          dest += left + this.translate(cap[1]) + right;
          continue;
        } // reflink


        if (cap = this.rules.reflink.exec(src)) {
          src = src.substring(cap[0].length);
          left = cap[0].substring(0, cap[0].indexOf(cap[1])).replace(/【/, '[');
          right = cap[0].substring(cap[0].indexOf(cap[1]) + cap[1].length).replace(/【/, '[').replace(/】/g, ']');
          dest += left + this.translate(cap[1]) + right;
          continue;
        } // linkdefinition


        if (cap = this.rules.linkdefinition.exec(src)) {
          src = src.substring(cap[0].length);
          dest += cap[0].replace(/【/, '[').replace(/】/, ']').replace(/：/, ':').replace(/[“”]/g, '"');
          continue;
        } // code


        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          dest += cap[0].replace(/·/g, '`');
          continue;
        } // text


        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          dest += cap[0];
          continue;
        }
      }

      return dest;
    };

    return InlineTranslator;
  }();

  var block$1 = rules.block;
  /**
   * Block Translator
   */

  var Translator_1 = /*#__PURE__*/function () {
    function Translator() {
      this.rules = block$1;
      this.dest = '';
    }

    Translator.translate = function translate(src) {
      var translator = new Translator();
      return translator.translate(src);
    };

    var _proto = Translator.prototype;

    _proto.translate = function translate(src) {
      // preprocessing
      src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
      var cap, left;

      while (src) {
        console.log(src); // newline

        if (cap = this.rules.newline.exec(src)) {
          src = src.substring(cap[0].length);
          this.dest += cap[0];
        } // fences


        if (cap = this.rules.fences.exec(src)) {
          src = src.substring(cap[0].length);
          this.dest += cap[0].replace(/[·]{3}/g, '```');
          continue;
        } // blockquote or listquote


        if (cap = this.rules.blockquote.exec(src) || this.rules.listquote.exec(src)) {
          src = src.substring(cap[0].length);
          left = cap[0].substring(0, cap[0].indexOf(cap[1])).replace(/[》〉]/g, '>');
          this.dest += left + InlineTranslator_1.translate(cap[1]);
          continue;
        } // text


        if (cap = this.rules.text.exec(src)) {
          console.log(cap);
          src = src.substring(cap[0].length);
          this.dest += InlineTranslator_1.translate(cap[0]);
        }
      }

      return this.dest;
    };

    return Translator;
  }();

  /**
   * Markable
   */

  function markable(src) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('markable(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('markable(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    return Translator_1.translate(src);
  }
  /**
   * Expose
   */

  var markable_1 = markable;

  return markable_1;

})));
