/**
 * markable - make non-English Markdown plain text markable
 * Copyright (c) 2020, Guxi11. (MIT Licensed)
 * https://github.com/hbhde/markable
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

/**
 * Helpers
 */

const caret = /(^|[^\[])\^/g;
function edit(regex) {
  regex = regex.source;
  const obj = {
    replace: (name, val) => {
      val = val.source;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
    },
    replaceAllByDict: (dict) => {
      for (let key in dict) {
        let name = key, val = dict[key];
        val = val.source;
        val = val.replace(caret, '$1');
        regex = regex.replace(RegExp(name, 'g'), val);
      }
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex);
    }
  };
  return obj;
}

var helpers = {
  edit
};

/**
 * Symbols
 * Supported Languages: Chinese
 */
const symbols = {
  '=`=': /`·/,
  '=~=': /~～/,
  '={=': /「/,
  '=}=': /」/,
  '=<=': /<《〈/,
  '=>=': />》〉/,
  '=:=': /:：/,
  '=!=': /!！/,
  '=_=': /——/,
  '=$=': /¥/,
  '="=': /"“”/,
  "='=": /'‘’/,
  '=\\\\\\[=': /\[【/, // Escaping twice
  '=\\\\\\]=': /\]】/,
  '=\\\\\\(=': /\(（/,
  '=\\\\\\)=': /\)）/,
  '=\\\\\\|=': /｜/,
  '=\\\\\\.=': /。/
};

var symbols_1 = symbols;

const { edit: edit$1 } = helpers;


/**
 * Block-Level Grammar
 */
const block = {
  newline: /^\n+/,
  fences: /^ {0,3}([=`=]{3,}(?=[^\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[=`=]* *(?:\n+|$)|$)/,
  blockquote: /^ {0,3}[=>=]+(([^\n]*)(?:\n|$))/,
  listquote: /^ *bull ?blockquote/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d{1,9}\.)/;
block.listquote = edit$1(block.listquote)
  .replace('bull', block.bullet)
  .replace('blockquote', block.blockquote)
  .getRegex();

/**
 * Inline-Level Grammar
 */
const inline = {
  link: /^[=!=]?[=\[=](label)[=\]=][=\(=]\s*(href)(?:\s+(title))?\s*[=\)=]/,
  reflink: /^[=!=]?[=\[=](label)[=\]=][=\[=](id)[=\]=]/,
  linkdefinition: /^[=\[=](id)[=\]=][=:=]\s*(href)(?:\s+(title))?/,
  code: /^([=`=]+)([^=`=]|[^=`=][\s\S]*?[^=`=])\1(?![=`=])/,
  text: /^([=`=]+|[^=`=])(?:[\s\S]*?(?:(?=[\\<!=\[==`=*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
};

inline._label = /(?:[=\[=][^=\[==\]=]*[=\]=]|\\.|[=`=][^=`=]*[=`=]|[^=\[==\]=\\=`=])*?/;
inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
inline._title = /[="=](?:\\[="=]?|[^="=\\])*[="=]|[='=](?:\\[='=]?|[^='=\\])*[='=]|[=\(=](?:\\[=\)=]?|[^)\\])*[=\)=]/;
inline._id = /(?!\s*[=\]=])((?:\\[=\[==\]=]?|[^=\[==\]=\\])+)/;

inline.link = edit$1(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit$1(inline.reflink)
  .replace('label', inline._label)
  .replace('id', inline._id)
  .getRegex();

inline.linkdefinition = edit$1(inline.linkdefinition)
  .replace('id', inline._id)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

/**
 * Grammar Translate Symbols
 */
[block, inline].map(grammer => {
  for (let key in grammer) {
    grammer[key] = edit$1(grammer[key])
      .replaceAllByDict(symbols_1)
      .getRegex();
  }
});

var rules = {
  block,
  inline
};

const { inline: inline$1 } = rules;

/**
 * InlineTranslator
 */
var InlineTranslator_1 = class InlineTranslator {
  constructor() {
    this.rules = inline$1;
  }

  static translate(src) {
    const translator = new InlineTranslator();
    return translator.translate(src);
  }

  translate(src) {
    let dest = '',
        cap,
        left,
        right;

    while(src) {

      // link
      if (cap = this.rules.link.exec(src)) {
        src = src.substring(cap[0].length);
        left = cap[0].substring(0, cap[0].indexOf(cap[1]))
          .replace(/！/, '!')
          .replace(/【/, '[');
        right = cap[0].substring(cap[0].indexOf(cap[1]) + cap[1].length)
          .replace(/】/, ']')
          .replace(/（/, '(')
          .replace(/）/, ')')
          .replace(/[“”]/g, '"');
        dest += left + this.translate(cap[1]) + right;
        continue;
      }

      // reflink
      if (cap = this.rules.reflink.exec(src)) {
        src = src.substring(cap[0].length);
        left = cap[0].substring(0, cap[0].indexOf(cap[1]))
          .replace(/【/, '[');
        right = cap[0].substring(cap[0].indexOf(cap[1]) + cap[1].length)
          .replace(/【/, '[')
          .replace(/】/g, ']');
        dest += left + this.translate(cap[1]) + right;
        continue;
      }

      // linkdefinition
      if (cap = this.rules.linkdefinition.exec(src)) {
        src = src.substring(cap[0].length);
        dest += cap[0]
          .replace(/【/, '[')
          .replace(/】/, ']')
          .replace(/：/, ':')
          .replace(/[“”]/g, '"');
        continue;
      }

      // code
      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        dest += cap[0]
          .replace(/·/g, '`');
        continue;
      }

      // text
      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        dest += cap[0];
        continue;
      }
    }

    return dest;
  }
};

const { block: block$1 } = rules;


/**
 * Block Translator
 */
var Translator_1 = class Translator {
  constructor() {
    this.rules = block$1;
    this.dest = '';
  }

  static translate(src) {
    const translator = new Translator();
    return translator.translate(src);
  }

  translate(src) {
    // preprocessing
    src = src
      .replace(/\r\n|\r/g, '\n')
      .replace(/\t/g, '    ');

    let cap,
        left;

    while(src) {
      // newline
      if (cap = this.rules.newline.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += cap[0];
      }

      // fences
      if (cap = this.rules.fences.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += cap[0]
          .replace(/[·]{3}/g, '```');
        continue;
      }

      // blockquote or listquote
      if (cap = this.rules.blockquote.exec(src) || this.rules.listquote.exec(src)) {
        src = src.substring(cap[0].length);
        left = cap[0].substring(0, cap[0].indexOf(cap[1]))
          .replace(/[》〉]/g, '>');
        this.dest += left + InlineTranslator_1.translate(cap[1]);
        continue;
      }

      // text
      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += InlineTranslator_1.translate(cap[0]);
      }
    }

    return this.dest;
  }
};

/**
 * Markable
 */
function markable(src) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('markable(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('markable(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  return Translator_1.translate(src);
}
/**
 * Expose
 */
var markable_1 = markable;

export default markable_1;
