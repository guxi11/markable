/**
 * markable - make non-English Markdown plain text markable
 * Copyright (c) 2020, Guxi11. (MIT Licensed)
 * https://github.com/hbhde/markable
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

/**
 * Helpers
 */

const caret = /(^|[^\[])\^/g;
function edit(regex) {
  regex = regex.source || regex;
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex);
    }
  };
  return obj;
}

var helpers = {
  edit
};

/**
 * Rules
 * Supported Languages: Chinese
 */
const symbols = {
  '=`=': /[·]/,
  '=~=': /[～]/,
  '={=': /[「]/,
  '=}=': /[」]/,
  '=[=': /[【]/,
  '=]=': /[】]/,
  '=(=': /[（]/,
  '=)=': /[）]/,
  '=)=': /[）]/,
  '=:=': /[：]/,
  '=!=': /[！]/,
  '=<=': /[《〈]/,
  '=>=': /[》〉]/,
  '=.=': /[。]/,
  '=_=': /[——]/,
  '=$=': /[¥]/,
  '=|=': /[｜]/
};

var symbols_1 = symbols;

const { edit: edit$1 } = helpers;


/**
 * Block-Level Grammar
 */
const block = {
  newline: /^\n+/,
  fences: /^ {0,3}(=`={3,}(?=[^\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1=`=* *(?:\n+|$)|$)/,
  blockquote: /^( {0,3}=>= ?([^\n]*)(?:\n|$))+/,
  text: /^[^\n]+/
};

block.fences = edit$1(block.fences)
  .replace(/=`=/g, symbols_1['=`='])
  .getRegex();

block.blockquote = edit$1(block.blockquote)
  .replace(/=>=/g, symbols_1['=>='])
  .getRegex();

var rules = {
  block
};

const { block: block$1 } = rules;

/**
 * Block Translator
 */
var Translator_1 = class Translator {
  constructor() {
    this.rules = block$1;
    this.dest = '';
  }

  static translate(src) {
    const translator = new Translator();
    return translator.translate(src);
  }

  translate(src) {
    // preprocessing
    src = src
      .replace(/\r\n|\r/g, '\n')
      .replace(/\t/g, '    ');

    let cap;

    while(src) {
      // newline
      if (cap = this.rules.newline.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += cap[0];
      }

      // fences
      if (cap = this.rules.fences.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += cap[0]
          .replace(/[·]{3}/g, '```');
      }

      // blockquote
      if (cap = this.rules.blockquote.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += cap[0]
          .replace(/》 /, '> ');
      }

      // text
      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        this.dest += cap[0];
      }
    }

    return this.dest;
  }
};

/**
 * Markable
 */
function markable(src) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('markable(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('markable(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  return Translator_1.translate(src);
}
/**
 * Expose
 */
var markable_1 = markable;

export default markable_1;
